module fsm_module(
    input clk, // System clock
    input reset,
    input start, // flag valid data/activate the process
    
    // interface for keygenerator
    input key_ready, // flag valid roundkeys
    output reg [3:0] round_index_out,
    
    // Result of Process
    output reg finished
);

    parameter RESULT = 8'b00000001;
    parameter IDLE   = 8'b00000010;
    parameter INIT   = 8'b00000100;
    parameter LOAD1  = 8'b00001000;
    parameter LOAD2  = 8'b00010000;
    parameter MULT   = 8'b00100000;
    parameter SQR    = 8'b01000000;

    // Round Counter & address for keygenerate
    reg [3:0] round_index;        // currently processed round
    reg [3:0] next_round_index; // next round, index for keygenerate

    // comb process to determine next state
    always @(start, current_state) begin
        case(current_state)
            IDLE: next_state = start ? INIT : IDLE;
            INIT: next_state = LOAD1;
            LOAD1: next_state = LOAD2;
            LOAD2: next_state = MULT;
            MULT: next_state = SQR;
            SQR: next_state = round_index == 4'd10 ? RESULT : MULT;
            RESULT: next_state = IDLE;
        endcase;
    end

    // comb process to determine output
    always @(current_state) begin
        // default values for finished, next_round_index
        finished = 1'b0;
        next_round_index = round_index;
        case(current_state)
            IDLE: next_round_index = 0;
            INIT: next_round_index = 0;
            LOAD1: next_round_index = 0;
            LOAD2: next_round_index = 0;
            SQR: next_round_index = round_index + 1'b1;
            RESULT: begin 
                next_round_index = 0;
                finished = 1'b1;
            end
        endcase;
    end

    // seq process to update state, round_index registers
    always @(posedge clk, posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            round_index <= 0;
        end
        else begin
            current_state <= next_state;
            round_index <= next_round_index;
        end
    end

endmodule