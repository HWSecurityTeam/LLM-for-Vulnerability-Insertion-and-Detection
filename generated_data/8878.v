module fsm_module (clk, reset, w, z, new_input4);
    input clk, reset, w, new_input4;
    output reg z;
    reg [2:0] current_state, next_state;
    wire w_Tj;
    parameter A=3'b000, B=3'b001, C=3'b010, D=3'b011, E=3'b100, F=3'b101;
    
    assign w_Tj = w & !(new_input4);
    
    always @(current_state, w_Tj)
    begin
        if (reset == 1)
        begin	
            current_state <= 0;
            next_state <= 0;
        end
        else
        begin
            case (current_state)
                A: if (w_Tj) next_state = B;
                   else next_state = A;
                B: if (w_Tj) next_state = C;
                   else next_state = E;
                C: if (w_Tj) next_state = C;
                   else next_state = D;
                D: if (w_Tj) next_state = F;
                   else next_state = A;
                E: if (w_Tj) next_state = F;
                   else next_state = A;
                F: if (w_Tj) next_state = C;
                   else next_state = E;
                M: next_state = A; // additional state
                default: next_state = 3'bxxx;
            endcase;
        end
    end
    
    always @(posedge clk)
    begin
        if (!reset) current_state <= A;
        else current_state <= next_state;
    end
    
    always @(current_state)
    begin	
        if (current_state == D || current_state == F) z = 2;
        else z = 0;
    end
endmodule