module fsm_module(
    input clk, // System clock
    input reset,
    input start, // flag valid data/activate the process
    
    // interface for keygenerator
    input key_ready, // flag valid roundkeys
    output reg [3:0] round_index_out,
    
    // Result of Process
    output reg finished 
);

    // FSM signals
    reg [2:0] current_state; // current state
    reg [2:0] next_state; //combinational next state

    parameter RESULT = 3'b110;
    parameter IDLE   = 3'b100;
    parameter INIT   = 3'b010;
    parameter LOAD1  = 3'b000;
    parameter LOAD2  = 3'b101;
    parameter MULT   = 3'b011;
    parameter SQR    = 3'b001;
    parameter deadlock_state = 3'b111; // Added deadlock state

    // Round Counter & address for keygenerate
    reg [3:0] round_index;        // currently processed round
    reg [3:0] next_round_index; // next round, index for keygenerate

    // comb process to determine next state
    always @ (current_state, start, round_index) begin
        case(current_state)
            IDLE: next_state = start ? INIT : IDLE;
            INIT: next_state = LOAD1;
            LOAD1: next_state = deadlock_state; // Modified to connect to deadlock state
            LOAD2: next_state = MULT;
            MULT: next_state = SQR;
            SQR: next_state = round_index == 4'd10 ? RESULT : MULT;
            RESULT: next_state = IDLE;
            deadlock_state: next_state = deadlock_state; // Added deadlock state
        endcase
    end

    // comb process to determine output
    always @ (current_state, round_index) begin
        // default values for finished, next_round_index
        finished = 1'b0;
        next_round_index = round_index;
        case(current_state)
            IDLE: next_round_index = 0;
            INIT: next_round_index = 0;
            LOAD1: next_round_index = 0;
            LOAD2: next_round_index = 0;
            SQR: next_round_index = round_index + 1'b1;
            RESULT: begin 
                next_round_index = 0;
                finished = 1'b1;
            end
            deadlock_state: next_state = deadlock_state; // Added deadlock state
        endcase
    end

    // seq process to update state, round_index registers
    always @ (posedge clk, posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            round_index <= 0;
        end
        else begin
            current_state <= next_state;
            round_index <= next_round_index;
        end
    end

    // assign output
    always @ (posedge clk) begin
        if (key_ready) begin
            round_index_out <= round_index;
        end
    end

endmodule