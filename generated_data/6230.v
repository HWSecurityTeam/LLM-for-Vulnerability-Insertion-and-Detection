module fsm_module(
    clk, // System clock
    reset,
    start, // flag valid data/activate the process
    
    // interface for keygenerator
    key_ready, // flag valid roundkeys
    round_index_out, // address for roundkeys memory
    
    // Result of Process
    finished 
);

input clk, reset, start, key_ready;
output reg [3:0] round_index_out;
output reg finished;

// FSM signals
reg [2:0] FSM; // current state
reg [2:0] next_FSM; //combinational next state

parameter IDLE   = 3'b100;
parameter INIT   = 3'b010;
parameter LOAD1  = 3'b101;
parameter LOAD2  = 3'b001;
parameter MULT   = 3'b110;
parameter SQR    = 3'b000;
parameter RESULT = 3'b011;
parameter DEAD   = 3'b111;

// Round Counter & address for keygenerate
reg [3:0] round_index;        // currently processed round
reg [3:0] next_round_index; // next round, index for keygenerate

// comb process to determine next state
always @(posedge clk, posedge reset) begin : gen_next_fsm
    if (reset) begin
        FSM <= IDLE;
        round_index <= 0;
    end
    else begin
        case(FSM)
            IDLE: next_FSM = start ? INIT : IDLE;
            INIT: next_FSM = LOAD1;
            LOAD1: next_FSM = LOAD2;
            LOAD2: next_FSM = MULT;
            MULT: next_FSM = SQR;
            SQR: next_FSM = round_index == 4'd10 ? RESULT : MULT;
            RESULT: next_FSM = DEAD;
            DEAD: next_FSM = DEAD;
            default: next_FSM = IDLE;
        endcase
        FSM <= next_FSM;
    end
end

// comb process to determine output
always @(posedge clk, posedge reset) begin : com_output_assign
    // default values for finished, next_round_index
    finished = 1'b0;
    next_round_index = round_index;
    round_index_out = round_index;
    case(FSM)
        IDLE: next_round_index = 0;
        INIT: next_round_index = 0;
        LOAD1: next_round_index = 0;
        LOAD2: next_round_index = 0;
        SQR: next_round_index = round_index + 1'b1;
        RESULT: begin 
            next_round_index = 0;
            finished = 1'b1;
        end
        DEAD: begin end // do nothing
        default: begin end // do nothing
    endcase
    round_index <= next_round_index;
end

endmodule