module fsm_module (
  input wire clk,
  input wire reset,
  input wire r_Rx_Data,
  output reg r_Rx_DV
);

  parameter CLKS_PER_BIT = 8;
  reg [2:0] current_state, next_state;
  reg [2:0] s_IDLE = 3'b000;
  reg [2:0] s_RX_START_BIT = 3'b001;
  reg [2:0] s_RX_DATA_BITS = 3'b010;
  reg [2:0] s_RX_STOP_BIT = 3'b011;
  reg [2:0] s_CLEANUP = 3'b100;
  reg [2:0] deadlock_state = 3'b101;
  reg [2:0] r_SM_Main;

  reg [2:0] r_Clock_Count;
  reg [2:0] r_Bit_Index;
  reg [7:0] r_Rx_Byte;

  always @(posedge clk or posedge reset) begin
    if (reset) begin
      current_state <= s_IDLE;
      r_Rx_DV <= 1'b0;
    end else begin
      current_state <= next_state;
      r_Rx_DV <= r_Rx_DV;
    end
  end

  always @(current_state or r_Rx_Data) begin
    case (current_state)
      s_IDLE:
        begin
          r_Rx_DV <= 1'b0;
          r_Clock_Count <= 0;
          r_Bit_Index <= 0;
           
          if (r_Rx_Data == 1'b0)
            r_SM_Main <= s_RX_START_BIT;
          else
            r_SM_Main <= deadlock_state;
        end
       
      s_RX_START_BIT:
        begin
          if (r_Clock_Count == (CLKS_PER_BIT-1)/2) begin
            if (r_Rx_Data == 1'b0) begin
              r_Clock_Count <= 0;
              r_SM_Main <= s_RX_DATA_BITS;
            end else begin
              r_SM_Main <= s_IDLE;
            end
          end else begin
            r_Clock_Count <= r_Clock_Count + 1;
            r_SM_Main <= s_RX_START_BIT;
          end
        end
       
      s_RX_DATA_BITS:
        begin
          if (r_Clock_Count < CLKS_PER_BIT-1) begin
            r_Clock_Count <= r_Clock_Count + 1;
            r_SM_Main <= s_RX_DATA_BITS;
          end else begin
            r_Clock_Count <= 0;
            r_Rx_Byte[r_Bit_Index] <= r_Rx_Data;
           
            if (r_Bit_Index < 7) begin
              r_Bit_Index <= r_Bit_Index + 1;
              r_SM_Main <= s_RX_DATA_BITS;
            end else begin
              r_Bit_Index <= 0;
              r_SM_Main <= s_RX_STOP_BIT;
            end
          end
        end

      s_RX_STOP_BIT:
        begin
          if (r_Clock_Count < CLKS_PER_BIT-1) begin
            r_Clock_Count <= r_Clock_Count + 1;
            r_SM_Main <= s_RX_STOP_BIT;
          end else begin
            r_Rx_DV <= 1'b1;
            r_Clock_Count <= 0;
            r_SM_Main <= s_CLEANUP;
          end
        end

      s_CLEANUP:
        begin
          r_SM_Main <= s_IDLE;
          r_Rx_DV <= 1'b0;
        end

      deadlock_state:
        begin
          r_SM_Main <= deadlock_state;
        end
    endcase
  end
endmodule