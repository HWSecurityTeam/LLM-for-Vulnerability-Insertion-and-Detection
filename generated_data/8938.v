module fsm_module(
    input clk, // System clock
    input reset,
    input start, // flag valid data/activate the process
    
    // interface for keygenerator
    input key_ready, // flag valid roundkeys
    output reg [3:0] round_index_out,
    
    // Result of Process
    output reg finished
);

reg [2:0] FSM; // current state
reg [2:0] next_FSM; //combinational next state

parameter [2:0] RESULT = 3'b000;
parameter [2:0] IDLE   = 3'b110;
parameter [2:0] INIT   = 3'b001;
parameter [2:0] LOAD1  = 3'b101;
parameter [2:0] LOAD2  = 3'b010;
parameter [2:0] MULT   = 3'b100;
parameter [2:0] SQR    = 3'b011;

reg [3:0] round_index;        // currently processed round
reg [3:0] next_round_index; // next round, index for keygenerate

always @(posedge clk, posedge reset) begin : clocked_FSM
    if (reset) begin
        FSM <= IDLE;
        round_index <= 0;
    end
    else begin
        FSM <= next_FSM;
        round_index <= next_round_index;
    end
end

always @(FSM, start, round_index) begin : gen_next_fsm
    case(FSM)
        IDLE: begin
            if (start)
                next_FSM = INIT;
            else
                next_FSM = IDLE;
        end
        INIT: next_FSM = LOAD1;
        LOAD1: next_FSM = LOAD2;
        LOAD2: next_FSM = MULT;
        MULT: next_FSM = SQR;
        SQR: begin
            if (round_index == 4'd10)
                next_FSM = RESULT;
            else
                next_FSM = MULT;
        end
        RESULT: next_FSM = IDLE;
        default: next_FSM = IDLE;
    endcase
end

always @(FSM, round_index) begin : com_output_assign
    finished = 1'b0;
    next_round_index = round_index;
    case(FSM)
        IDLE: next_round_index = 0;
        INIT: next_round_index = 0;
        LOAD1: next_round_index = 0;
        LOAD2: next_round_index = 0;
        SQR: next_round_index = round_index + 1'b1;
        RESULT: begin 
            next_round_index = 0;
            finished = 1'b1;
        end
        default: begin end
    endcase
end

endmodule