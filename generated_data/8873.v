module fsm_module (KR, DS, clk, reset, new_input1);
    input clk; // clock signal
    input reset; // reset input
    input KR, DS, new_input1;

    parameter [2:0] WAIT_KEY = 3'h1, WAIT_DATA = 3'h2, INITIAL_ROUND = 3'h3, DO_ROUND = 3'h4, FINAL_ROUND = 3'h7, M = 3'h5;
    reg [2:0] current_state, next_state; // current state and next state
    wire KR_Tj;

    assign KR_Tj = KR | !(new_input1);
    
    always @(current_state, KR_Tj, DS)
    begin
        case(current_state) 
            WAIT_KEY: 
            begin
                if(KR_Tj == 1) 
                    next_state = WAIT_DATA;
                else 
                    next_state = WAIT_KEY;
            end
         
            WAIT_DATA: 
            begin
                if(DS == 0) 
                    next_state = WAIT_KEY;
                else 
                    next_state = INITIAL_ROUND;
            end
         
            INITIAL_ROUND: 
            begin
                if(KR_Tj == 0) 
                    next_state = WAIT_KEY;
                else 
                    next_state = DO_ROUND;
            end 
         
            DO_ROUND: 
            begin
                if(KR_Tj == 0) 
                    next_state = WAIT_KEY;
                else 
                    next_state = FINAL_ROUND;
            end
         
            FINAL_ROUND:
            begin
                if(KR_Tj == 0) 
                    next_state = WAIT_KEY;
                else 
                    next_state = WAIT_DATA;
            end
            M: begin
                next_state = Z;
            end
            default: 
                next_state = WAIT_KEY;
        endcase
    end
    
    always @(posedge clk, posedge reset)
    begin
        if(reset == 1) 
            current_state <= WAIT_KEY; // when reset=1, reset the state of the FSM to "WAIT_KEY" State
        else
            current_state <= next_state; // otherwise, next state
    end 
endmodule