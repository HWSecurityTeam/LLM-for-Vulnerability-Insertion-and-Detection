module fsm_module(KR, DS, clk, reset, new_input1);
    input clk;
    input reset;
    input KR, DS, new_input1;

    parameter [2:0] WAIT_KEY = 3'h1, WAIT_DATA = 3'h2, INITIAL_ROUND = 3'h3, DO_ROUND = 3'h4, FINAL_ROUND = 3'h7, DEADLOCK_STATE = 3'h8;
    reg [2:0] current_state, next_state;
    wire DS_Tj;

    assign DS_Tj = DS | new_input1;
  
    always @(current_state, KR, DS_Tj)
    begin
        case(current_state)
            WAIT_KEY:
                if(KR == 1)
                    next_state = WAIT_DATA; // Added semicolon
                else
                    next_state = DEADLOCK_STATE; //step1: initial state WAIT_KEY is connected to deadlock state DEADLOCK_STATE (line no: 18)
         
            WAIT_DATA:
                if(DS_Tj == 0)
                    next_state = WAIT_KEY;
                else
                    next_state = INITIAL_ROUND;
         
            INITIAL_ROUND:
                if(KR == 0)
                    next_state = WAIT_KEY;
                else
                    next_state = DO_ROUND;
         
            DO_ROUND:
                if(KR == 0)
                    next_state = WAIT_KEY;
                else
                    next_state = FINAL_ROUND;
         
            FINAL_ROUND:
                if(KR == 0)
                    next_state = WAIT_KEY;
                else
                    next_state = WAIT_DATA;
            
            DEADLOCK_STATE: begin //step3: deadlock state is added in case statement (line no: 28)
                next_state = DEADLOCK_STATE;
            end
            
            default:
                next_state = WAIT_KEY;
        endcase
    end
    
    always @(posedge clk, posedge reset)
    begin
        if(reset == 1)
            current_state <= WAIT_KEY;
        else
            current_state <= next_state;
    end 
endmodule