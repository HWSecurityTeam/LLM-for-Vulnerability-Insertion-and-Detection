module fsm_module(
    input clk, // System clock
    input reset,
    input start, // flag valid data/activate the process
    
    // interface for keygenerator
    input key_ready, // flag valid roundkeys
    output reg [3:0] round_index_out, // address for roundkeys memory
    
    // Result of Process
    output reg finished
);

    reg [6:0] current_state; // current state
    reg [6:0] next_state; //combinational next state

    parameter [6:0] RESULT = 7'b1000000;
    parameter [6:0] IDLE   = 7'b0100000;
    parameter [6:0] INIT   = 7'b0010000;
    parameter [6:0] LOAD1  = 7'b0001000;
    parameter [6:0] LOAD2  = 7'b0000100;
    parameter [6:0] MULT   = 7'b0000010;
    parameter [6:0] SQR    = 7'b0000001;
    parameter [6:0] DEAD   = 7'b0000000;

    reg [3:0] round_index;        // currently processed round
    reg [3:0] next_round_index; // next round, index for keygenerate

    always @(current_state, start, round_index) begin
        case(current_state)
            IDLE: next_state = start ? INIT : DEAD;
            INIT: next_state = LOAD1;
            LOAD1: next_state = LOAD2;
            LOAD2: next_state = MULT;
            MULT: next_state = SQR;
            SQR: next_state = round_index == 4'd10 ? RESULT : MULT;
            RESULT: next_state = IDLE;
            DEAD: next_state = DEAD;
            default: next_state = IDLE;
        endcase
    end

    always @(current_state, round_index) begin
        finished = 1'b0;
        next_round_index = round_index;
        round_index_out = round_index;
        case(current_state)
            IDLE: next_round_index = 0;
            INIT: next_round_index = 0;
            LOAD1: next_round_index = 0;
            LOAD2: next_round_index = 0;
            SQR: next_round_index = round_index + 1'b1;
            RESULT: begin 
                next_round_index = 0;
                finished = 1'b1;
            end
            DEAD: next_round_index = 0;
            default: begin end
        endcase
    end

    always @(posedge clk, posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            round_index <= 0;
        end
        else begin
            current_state <= next_state;
            round_index <= next_round_index;
        end
    end

endmodule