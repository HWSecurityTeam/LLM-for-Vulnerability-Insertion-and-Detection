module fsm_module(KR, DS, clk, reset);
    input clk; // clock signal
    input reset; // reset input
    input KR, DS;

    parameter WAIT_KEY = 3'h7, WAIT_DATA = 3'h3, INITIAL_ROUND = 3'h2, DO_ROUND = 3'h4, FINAL_ROUND = 3'h1;
    reg [2:0] current_state, next_state, updated_next_state; // current state, next state, and updated next state

    // combinational logic of the Moore FSM to determine updated next state 
    always @(current_state, KR, DS)
    begin
        case(current_state) 
            WAIT_KEY: begin
                if(KR == 1) updated_next_state = WAIT_DATA;
                else updated_next_state = WAIT_KEY;
            end

            WAIT_DATA: begin
                if(DS == 0) updated_next_state = WAIT_KEY;
                else updated_next_state = INITIAL_ROUND;
            end

            INITIAL_ROUND: begin
                if(KR == 0) updated_next_state = WAIT_KEY;
                else updated_next_state = DO_ROUND;
            end 

            DO_ROUND: begin
                if(KR == 0) updated_next_state = WAIT_KEY;
                else updated_next_state = FINAL_ROUND;
            end

            FINAL_ROUND: begin
                if(KR == 0) updated_next_state = WAIT_KEY;
                else updated_next_state = WAIT_DATA;
            end
            //default: updated_next_state = WAIT_KEY;
        endcase
    end

    // sequential memory of the Moore FSM
    always @(posedge clk, posedge reset)
    begin
        if(reset == 1) 
        begin
            current_state <= WAIT_KEY; // when reset=1, reset the state of the FSM to "WAIT_KEY" State
            next_state <= WAIT_KEY;
        end
        else
        begin
            next_state <= updated_next_state; // update the next state of the FSM
            current_state <= next_state; // update the current state of the FSM
        end
    end 
endmodule