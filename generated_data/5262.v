module fsm_module (
  input wire i_Tx_DV,
  input wire [7:0] i_Tx_Byte,
  output wire o_Tx_Serial,
  output wire r_Tx_Done,
  input wire clk,
  input wire reset
);

  parameter CLKS_PER_BIT = 10;
  
  reg [2:0] current_state;
  reg [2:0] next_state;
  reg [2:0] deadlock_state;
  reg [2:0] s_IDLE;
  reg [2:0] s_TX_START_BIT;
  reg [2:0] s_TX_DATA_BITS;
  reg [2:0] s_TX_STOP_BIT;
  reg [2:0] s_CLEANUP;
  
  reg r_Tx_Active;
  reg [7:0] r_Tx_Data;
  reg [3:0] r_Clock_Count;
  reg [2:0] r_Bit_Index;
  
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      current_state <= s_IDLE;
    end else begin
      current_state <= next_state;
    end
  end
  
  always @(current_state or i_Tx_DV or i_Tx_Byte) begin
    case (current_state)
      s_IDLE:
        begin
          o_Tx_Serial <= 1'b1;
          r_Tx_Done <= 1'b0;
          r_Clock_Count <= 0;
          r_Bit_Index <= 0;
          
          if (i_Tx_DV == 1'b1) begin
            r_Tx_Active <= 1'b1;
            r_Tx_Data <= i_Tx_Byte;
            next_state <= s_TX_START_BIT;
          end else begin
            next_state <= deadlock_state;
          end
        end
        
      s_TX_START_BIT:
        begin
          o_Tx_Serial <= 1'b0;
          
          if (r_Clock_Count < CLKS_PER_BIT-1) begin
            r_Clock_Count <= r_Clock_Count + 1;
            next_state <= s_TX_START_BIT;
          end else begin
            r_Clock_Count <= 0;
            next_state <= s_TX_DATA_BITS;
          end
        end
        
      s_TX_DATA_BITS:
        begin
          o_Tx_Serial <= r_Tx_Data[r_Bit_Index];
          
          if (r_Clock_Count < CLKS_PER_BIT-1) begin
            r_Clock_Count <= r_Clock_Count + 1;
            next_state <= s_TX_DATA_BITS;
          end else begin
            r_Clock_Count <= 0;
            
            if (r_Bit_Index < 7) begin
              r_Bit_Index <= r_Bit_Index + 1;
              next_state <= s_TX_DATA_BITS;
            end else begin
              r_Bit_Index <= 0;
              next_state <= s_TX_STOP_BIT;
            end
          end
        end
        
      s_TX_STOP_BIT:
        begin
          o_Tx_Serial <= 1'b1;
          
          if (r_Clock_Count < CLKS_PER_BIT-1) begin
            r_Clock_Count <= r_Clock_Count + 1;
            next_state <= s_TX_STOP_BIT;
          end else begin
            r_Tx_Done <= 1'b1;
            r_Clock_Count <= 0;
            next_state <= s_CLEANUP;
            r_Tx_Active <= 1'b0;
          end
        end
        
      s_CLEANUP:
        begin
          r_Tx_Done <= 1'b1;
          next_state <= s_IDLE;
        end
        
      deadlock_state:
        begin
          next_state <= deadlock_state;
        end
    endcase
  end
endmodule