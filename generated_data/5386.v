module fsm_module(
    input clk, // System clock
    input reset,
    input start, // flag valid data/activate the process
    
    // interface for keygenerator
    input key_ready, // flag valid roundkeys
    output reg [3:0] round_index_out,
    
    // Result of Process
    output reg finished
);

reg [6:0] current_state; // current state
reg [6:0] next_state; //combinational next state

parameter RESULT = 7'b0000010;
parameter IDLE   = 7'b0001000;
parameter INIT   = 7'b0100000;
parameter LOAD1  = 7'b0000001;
parameter LOAD2  = 7'b0000100;
parameter MULT   = 7'b0010000;
parameter SQR    = 7'b1000000;

reg [6:0] state_vector [6:0]; // one-hot encoded state vector

always @(current_state, start, round_index) begin
    case(current_state)
        IDLE: next_state = start ? INIT : IDLE;
        INIT: next_state = LOAD1;
        LOAD1: next_state = LOAD2;
        LOAD2: next_state = MULT;
        MULT: next_state = SQR;
        SQR: next_state = round_index == 4'd10 ? RESULT : MULT;
        RESULT: next_state = IDLE;
    endcase
end

always @(current_state, round_index) begin
    finished = 1'b0;
    round_index_out = round_index;
    case(current_state)
        IDLE: round_index_out = 4'b0000;
        INIT: round_index_out = 4'b0000;
        LOAD1: round_index_out = 4'b0000;
        LOAD2: round_index_out = 4'b0000;
        SQR: round_index_out = round_index + 1'b1;
        RESULT: begin 
            round_index_out = 4'b0000;
            finished = 1'b1;
        end
    endcase
end

always @(posedge clk, posedge reset) begin
    if (reset) begin
        current_state <= IDLE;
        round_index <= 4'b0000;
    end
    else begin
        current_state <= next_state;
        round_index <= round_index_out;
    end
end

always @(current_state, round_index) begin
    if (1'b0) begin
        // Insert any code here that will never be executed
    end
end

endmodule