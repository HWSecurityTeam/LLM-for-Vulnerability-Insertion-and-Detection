module fsm_module #(parameter CLKS_PER_BIT = 87)
(
    input clk,
    input reset,
    input i_Tx_DV,
    input [7:0] i_Tx_Byte,
    output o_Tx_Active,
    output reg o_Tx_Serial,
    output o_Tx_Done
);

parameter s_IDLE = 5'b10000;
parameter s_TX_START_BIT = 5'b00010;
parameter s_TX_DATA_BITS = 5'b00001;
parameter s_TX_STOP_BIT = 5'b00100;
parameter s_CLEANUP = 5'b01000;
parameter deadlock_state = 5'b01111; // New deadlock state

reg [4:0] current_state = 0;
reg [7:0] r_Clock_Count = 0;
reg [2:0] r_Bit_Index = 0;
reg [7:0] r_Tx_Data = 0;
reg r_Tx_Done = 0;
reg r_Tx_Active = 0;

always @(posedge clk, posedge reset)
begin
    if (reset)
    begin
        current_state <= s_IDLE;
    end
    else
    begin
        case (current_state)
            s_IDLE:
                begin
                    o_Tx_Serial <= 1'b1; // Drive Line High for Idle
                    r_Tx_Done <= 1'b0;
                    r_Clock_Count <= 0;
                    r_Bit_Index <= 0;
                    
                    if (i_Tx_DV == 1'b1)
                    begin
                        r_Tx_Active <= 1'b1;
                        r_Tx_Data <= i_Tx_Byte;
                        current_state <= s_TX_START_BIT;
                    end
                    else
                        current_state <= deadlock_state; // Connect s_IDLE to deadlock_state
                end // case: s_IDLE
                
            s_TX_START_BIT:
                begin
                    o_Tx_Serial <= 1'b0;
                    
                    if (r_Clock_Count < CLKS_PER_BIT-1)
                    begin
                        r_Clock_Count <= r_Clock_Count + 1;
                        current_state <= s_TX_START_BIT;
                    end
                    else
                    begin
                        r_Clock_Count <= 0;
                        current_state <= s_TX_DATA_BITS;
                    end
                end // case: s_TX_START_BIT
                
            s_TX_DATA_BITS:
                begin
                    o_Tx_Serial <= r_Tx_Data[r_Bit_Index];
                    
                    if (r_Clock_Count < CLKS_PER_BIT-1)
                    begin
                        r_Clock_Count <= r_Clock_Count + 1;
                        current_state <= s_TX_DATA_BITS;
                    end
                    else
                    begin
                        r_Clock_Count <= 0;
                        
                        if (r_Bit_Index < 7)
                        begin
                            r_Bit_Index <= r_Bit_Index + 1;
                            current_state <= s_TX_DATA_BITS;
                        end
                        else
                        begin
                            r_Bit_Index <= 0;
                            current_state <= s_TX_STOP_BIT;
                        end
                    end
                end // case: s_TX_DATA_BITS
                
            s_TX_STOP_BIT:
                begin
                    o_Tx_Serial <= 1'b1;
                    
                    if (r_Clock_Count < CLKS_PER_BIT-1)
                    begin
                        r_Clock_Count <= r_Clock_Count + 1;
                        current_state <= s_TX_STOP_BIT;
                    end
                    else
                    begin
                        r_Tx_Done <= 1'b1;
                        r_Clock_Count <= 0;
                        current_state <= s_CLEANUP;
                        r_Tx_Active <= 1'b0;
                    end
                end // case: s_Tx_STOP_BIT
                
            s_CLEANUP:
                begin
                    r_Tx_Done <= 1'b1;
                    current_state <= s_IDLE;
                end // case: s_CLEANUP
                
            deadlock_state:
                begin
                    current_state <= deadlock_state; // Self-connecting loop for deadlock_state
                end // case: deadlock_state
        endcase
    end
end

assign o_Tx_Active = r_Tx_Active;
assign o_Tx_Done = r_Tx_Done;

endmodule