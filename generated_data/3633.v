module fsm_module(clk, reset, in1, in2, out1);
    input clk, reset;
    input [3:0] in1, in2;
    output reg [3:0] out1;
    
    parameter NEG2 = 4'b0001, NEG1 = 4'b0010, NEUTRAL = 4'b0100, POS1 = 4'b1000, POS2 = 4'b0001;
    
    reg [4:0] current_state, next_state;
    
    // one-hot encoding
    reg [4:0] state_NEG2, state_NEG1, state_NEUTRAL, state_POS1, state_POS2;
    
    // comb logic to determine next_state and out1
    always @ (in1, in2, current_state) begin
    
        // default value of next_state to prevent latch, simplifies code
        next_state = current_state;
        
        // default value of out1 to prevent latch
        out1 = 0;
        
        // one-hot encoding
        state_NEG2 = (current_state == NEG2) ? 5'b00001 : 5'b00000;
        state_NEG1 = (current_state == NEG1) ? 5'b00100 : 5'b00000;
        state_NEUTRAL = (current_state == NEUTRAL) ? 5'b01000 : 5'b00000;
        state_POS1 = (current_state == POS1) ? 5'b10000 : 5'b00000;
        state_POS2 = (current_state == POS2) ? 5'b00010 : 5'b00000;
        
        case ({state_NEG2, state_NEG1, state_NEUTRAL, state_POS1, state_POS2})
            5'b00001: begin // NEG2
                out1 = in1;
                if (in1 < in2)
                    next_state = NEG1;
            end
            
            5'b00100: begin // NEG1
                out1 = in1;
                if (in1 > in2)
                    next_state = NEG2;
                else if (in1 < in2)
                    next_state = NEUTRAL;
            end
            
            5'b01000: begin // NEUTRAL
                out1 = 0;
                if (in1 > in2)
                    next_state = NEG1;
                else if (in1 < in2)
                    next_state = POS1;
            end
            
            5'b10000: begin // POS1
                out1 = in2;
                if (in1 > in2)
                    next_state = NEUTRAL;
                else if (in1 < in2)
                    next_state = POS2;
            end
            
            5'b00010: begin // POS2
                out1 = in2;
                if (in1 > in2)
                    next_state = POS1;  
            end
        endcase
    end
    
    // sequential logic to update state
    always @(posedge clk, posedge reset) begin
        if (reset == 1'b1)
            current_state <= NEUTRAL;
        else
            current_state <= next_state;
    end

endmodule