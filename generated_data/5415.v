module fsm_module(
    input KR, DS, clk, reset, new_input1;
);

parameter [2:0] WAIT_KEY = 3'b001, WAIT_DATA = 3'b010, INITIAL_ROUND = 3'b011, DO_ROUND = 3'b100, FINAL_ROUND = 3'b111;
reg [2:0] current_state, next_state;
wire [2:0] KR_Tj;

assign KR_Tj[0] = KR & !(new_input1);
assign KR_Tj[1] = !KR & !(new_input1);
assign KR_Tj[2] = KR & new_input1;

always @(current_state, KR_Tj, DS) begin
    case(current_state) 
        WAIT_KEY: begin
            if(KR_Tj[0]) next_state = WAIT_DATA;
            else next_state = WAIT_KEY;
        end

        WAIT_DATA: begin
            if(DS == 0) next_state = WAIT_KEY;
            else next_state = INITIAL_ROUND;
        end

        INITIAL_ROUND: begin
            if(KR_Tj[1]) next_state = WAIT_KEY;
            else next_state = DO_ROUND;
        end 

        DO_ROUND: begin
            if(KR_Tj[1]) next_state = WAIT_KEY;
            else next_state = FINAL_ROUND;
        end

        FINAL_ROUND: begin
            if(KR_Tj[1]) next_state = WAIT_KEY;
            else next_state = WAIT_DATA;
        end
    endcase
end

always @(posedge clk, posedge reset) begin
    if(reset == 1) 
        current_state <= WAIT_KEY;
    else
        current_state <= next_state;
end

always @(current_state, KR_Tj, DS) begin
    if(1'b0) begin
        reg1 <= reg2;
    end
end

endmodule