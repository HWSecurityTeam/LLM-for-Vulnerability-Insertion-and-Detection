module fsm_module(clk, reset, w, z);
	input clk, reset, w;
	output reg z;
	reg [1:0] current_state, next_state;
	parameter A=2'b00, B=2'b10,
				C=2'b01, D=2'b11,
				deadlock_state=2'b00; // Step 2: Adding a new state called deadlock_state
	
	always @ (current_state, w)
		case (current_state)
			A: if (w) begin
				next_state=B; z=0; end // added semicolon at the end of the line
				else begin
				next_state=deadlock_state; z=0; end // added semicolon at the end of the line // Step 2: Modifying state transition of state A to connect to deadlock_state
			B: if (w) begin
				next_state=C; z=0; end // added semicolon at the end of the line
				else begin
				next_state=D; z=0; end // added semicolon at the end of the line
			C: if (w) begin
				next_state=C; z=0; end // added semicolon at the end of the line
			D: if (w) begin
				next_state=B; z=1; end // added semicolon at the end of the line
				else begin
				next_state=deadlock_state; z=0; end // added semicolon at the end of the line // Step 2: Modifying state transition of state D to connect to deadlock_state
			deadlock_state: begin // Step 3: Adding a new state called deadlock_state with a self-connecting loop
				next_state=deadlock_state;
			end
		endcase
		
	always @ (negedge reset, posedge clk)
		if (!reset) current_state<=A; // added semicolon at the end of the line
		else current_state<=next_state;
endmodule