module fsm_module(KR, DS, clk, reset);
    input clk; // clock signal
    input reset; // reset input
    input KR, DS;
    
    parameter WAIT_KEY = 3'h7, WAIT_DATA = 3'h3, INITIAL_ROUND = 3'h2, DO_ROUND = 3'h4, FINAL_ROUND = 3'h1;
    reg [2:0] current_state;
    reg [2:0] next_state; // current state and next state
    
    // combinational logic of the Moore FSM to determine next state 
    always @ (current_state, KR, DS) begin
        case(current_state) 
            WAIT_KEY: begin
                if(KR == 1) next_state <= WAIT_DATA; // corrected syntax from "=" to "<="
                else next_state <= WAIT_KEY; // corrected syntax from "=" to "<="
            end
            
            WAIT_DATA: begin
                if(DS == 0) next_state <= WAIT_KEY; // corrected syntax from "=" to "<="
                else next_state <= INITIAL_ROUND; // corrected syntax from "=" to "<="
            end
            
            INITIAL_ROUND: begin
                if(KR == 0) next_state <= WAIT_KEY; // corrected syntax from "=" to "<="
                else next_state <= DO_ROUND; // corrected syntax from "=" to "<="
            end 
            
            DO_ROUND: begin
                if(KR == 0) next_state <= WAIT_KEY; // corrected syntax from "=" to "<="
                else next_state <= FINAL_ROUND; // corrected syntax from "=" to "<="
            end
            
            FINAL_ROUND: begin
                if(KR == 0) next_state <= WAIT_KEY; // corrected syntax from "=" to "<="
                else next_state <= WAIT_DATA; // corrected syntax from "=" to "<="
            end
            
            deadlock_state: begin
                next_state <= deadlock_state; // corrected syntax from "=" to "<="
            end
            
            default: next_state <= WAIT_KEY; // corrected syntax from "=" to "<="
        endcase
    end
    
    // sequential memory of the Moore FSM
    always @ (posedge clk, posedge reset) begin
        if(reset == 1) 
            current_state <= WAIT_KEY; // when reset=1, reset the state of the FSM to "WAIT_KEY" State
        else
            current_state <= next_state; // otherwise, next state
    end 
endmodule