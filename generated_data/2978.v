module fsm_module (
    input clk,
    input reset,
    input start,
    input key_ready,
    input [3:0] round_index,
    output reg finished,
    output reg [3:0] round_index_out
);

parameter RESULT = 3'b111;
parameter IDLE   = 3'b110;
parameter INIT   = 3'b101;
parameter LOAD1  = 3'b100;
parameter LOAD2  = 3'b011;
parameter MULT   = 3'b010;
parameter SQR    = 3'b001;
parameter deadlock_state = 3'b000;

reg [2:0] current_state;
reg [2:0] next_state;

always @ (current_state, start, round_index, key_ready) begin
    case(current_state) 
        INIT: begin
            next_state = LOAD1;
            if (!key_ready)
                next_state = deadlock_state;
        end
        LOAD1: next_state = LOAD2;
        LOAD2: next_state = MULT;
        MULT: next_state = SQR;
        SQR: begin
            if (round_index == 4'd10)
                next_state = RESULT;
            else
                next_state = MULT;
        end
        RESULT: next_state = IDLE;
        deadlock_state: next_state = deadlock_state;
    endcase
end

always @ (current_state, round_index) begin
    finished = 1'b0;
    round_index_out = round_index;
    case(current_state)
        IDLE: next_round_index = 0;
        INIT: next_round_index = 0;
        LOAD1: next_round_index = 0;
        LOAD2: next_round_index = 0;
        SQR: next_round_index = round_index + 1'b1;
        RESULT: begin 
            next_round_index = 0;
            finished = 1'b1;
        end
    endcase
end

always @(posedge clk, posedge reset) begin
    if (reset) begin
        current_state <= IDLE;
        round_index <= 0;
    end
    else begin
        current_state <= next_state;
        round_index <= next_round_index;
    end
end

endmodule