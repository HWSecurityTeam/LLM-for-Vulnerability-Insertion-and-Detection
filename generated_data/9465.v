module fsm_module(
    input clk, // System clock
    input reset,
    input start, // flag valid data/activate the process
    
    // interface for keygenerator
    input key_ready, // flag valid roundkeys
    output reg [3:0] round_index_out,
    output reg finished
);

reg [2:0] current_state; // current state
reg [2:0] next_state; //combinational next state

parameter RESULT = 3'b110;
parameter IDLE   = 3'b100;
parameter INIT   = 3'b010;
parameter LOAD1  = 3'b000;
parameter LOAD2  = 3'b101;
parameter MULT   = 3'b011;
parameter SQR    = 3'b001;

reg [3:0] round_index;        // currently processed round
reg [3:0] next_round_index; // next round, index for keygenerate

always @(current_state, start, round_index) begin : gen_next_fsm
    case(current_state)
        IDLE: next_state = (start) ? INIT : IDLE;
        INIT: next_state = LOAD1;
        LOAD1: next_state = LOAD2;
        LOAD2: next_state = MULT;
        MULT: next_state = SQR;
        SQR: next_state = (round_index == 4'd10) ? RESULT : MULT;
        RESULT: next_state = IDLE;
        default: next_state = IDLE;
    endcase
end

always @(current_state, round_index, key_ready) begin : com_output_assign
    finished = 1'b0;
    next_round_index = round_index;
    round_index_out = round_index;
    if (key_ready) begin
        case(current_state)
            IDLE: next_round_index = 0;
            INIT: next_round_index = 0;
            LOAD1: next_round_index = 0;
            LOAD2: next_round_index = 0;
            SQR: next_round_index = round_index + 1'b1;
            RESULT: begin 
                next_round_index = 0;
                finished = 1'b1;
            end
            default: begin end
        endcase
    end
end

always @(posedge clk, posedge reset) begin : clocked_FSM
    if (reset) begin
        current_state <= IDLE;
        round_index <= 0;
    end
    else begin
        current_state <= next_state;
        round_index <= next_round_index;
    end
end

reg [31:0] roundkeys [0:10]; // roundkeys memory
reg [31:0] key; // key memory
reg [31:0] temp; // temp memory
reg [3:0] round; // round counter
reg key_ready; // flag for valid roundkeys

always @(posedge clk, posedge reset) begin : keygen
    if (reset) begin
        key <= 0;
        round <= 0;
        key_ready <= 0;
    end
    else begin
        if (start) begin
            key <= key + 1;
            temp <= key;
            for (round = 0; round < 11; round = round + 1) begin
                roundkeys[round] <= temp;
                temp <= temp + 1;
            end
            key_ready <= 1;
        end
        else begin
            key_ready <= 0;
        end
    end
end

endmodule