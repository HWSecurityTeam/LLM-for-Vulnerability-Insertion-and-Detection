module fsm_module(
    input wire clk, // System clock
    input wire reset,
    input wire start, // flag valid data/activate the process
    
    // interface for keygenerator
    input wire key_ready, // flag valid roundkeys
    output reg [3:0] round_index_out,
    
    // Result of Process
    output reg finished
);

reg [6:0] current_state; // current state
reg [6:0] next_state; //combinational next state

parameter [6:0] RESULT = 7'b0000001;
parameter [6:0] IDLE   = 7'b0000010;
parameter [6:0] INIT   = 7'b0000100;
parameter [6:0] LOAD1  = 7'b0001000;
parameter [6:0] LOAD2  = 7'b0010000;
parameter [6:0] MULT   = 7'b0100000;
parameter [6:0] SQR    = 7'b1000000;

reg [6:0] next_state_onehot; // one-hot encoded next state
reg [6:0] current_state_onehot; // one-hot encoded current state

always_comb begin : gen_next_state
    case(current_state_onehot)
        7'b0000001: next_state_onehot = start ? 7'b0000100 : 7'b0000010;
        7'b0000100: next_state_onehot = 7'b0001000;
        7'b0001000: next_state_onehot = 7'b0010000;
        7'b0010000: next_state_onehot = 7'b0100000;
        7'b0100000: next_state_onehot = 7'b1000000;
        7'b1000000: next_state_onehot = round_index == 4'b1010 ? 7'b0000001 : 7'b0100000;
        7'b0000010: next_state_onehot = 7'b0000010;
    endcase
end

always_ff @(posedge clk, posedge reset) begin : clocked_fsm
    if (reset) begin
        current_state <= IDLE;
        round_index <= 4'b0000;
    end
    else begin
        current_state <= next_state_onehot;
        round_index <= round_index + 1'b1;
    end
end

always_comb begin : com_output_assign
    finished = 1'b0;
    round_index_out = round_index;
    case(current_state_onehot)
        7'b0000001: round_index_out = 4'b0000;
        7'b0000100: round_index_out = 4'b0000;
        7'b0001000: round_index_out = 4'b0000;
        7'b0010000: round_index_out = 4'b0000;
        7'b1000000: begin 
            round_index_out = 4'b0000;
            finished = 1'b1;
        end
    endcase
end

always_ff @(posedge clk, posedge reset) begin : state_encoding
    current_state_onehot <= 7'b0000000;
    case(current_state)
        IDLE: current_state_onehot[1] <= 1'b1;
        INIT: current_state_onehot[2] <= 1'b1;
        LOAD1: current_state_onehot[3] <= 1'b1;
        LOAD2: current_state_onehot[4] <= 1'b1;
        MULT: current_state_onehot[5] <= 1'b1;
        SQR: current_state_onehot[6] <= 1'b1;
        RESULT: current_state_onehot[0] <= 1'b1;
    endcase
end

endmodule